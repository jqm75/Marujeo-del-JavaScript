# ‚ö° Marujeo del JavaScript ‚ö°

## √çndice

 
  - [**Variables**](#variables)
  - [**Tipos de datos**](#tipos-de-datos)
  - [**typeOf**](#typeof)
  - [**Cambiar contenido HTML con getElementById()**](#cambiar-contenido-html-con-getelementbyid)
  - [**for**](#for)
  - [**while**](#while)
  - [**do while**](#do-while)
  - [**forEach**](#foreach)
  - [**for of**](#for-of)
  - [**for in**](#for-in)
  - [**break**](#break)
  - [**Arrays**](#arrays)
  - [**M√©todos de Array**](#m√©todos-de-array)
  - [**Objetos**](#objetos)
  - [**Operador Rest y Spread**](#operador-rest-y-spread)
  - [**Funciones**](#funciones)
  - [**Clousure**](#clousure)
  - [**Asincron√≠as**](#asincron√≠as)
  - [**Arrow Fuctions**](#arrow-functions)
  - [**Condicionales**](#condicionales)
  - [**Window**](#window)
  - [**Template literal**](#template-literal)
  - [**Convertir a STRING o NUMBER**](#convertir-a-string-o-number)
---

## **Variables**
---

Las variables son cajas, contenedores donde guardar datos y se pueden cambiar por otros. Es quiere decir que es **mutable**.
B√°sicamente hay de dos tipos: `let` y `const`. Tambi√©n existe `var`, que hay que evitar.

**var** ‚Üí Declara una variable en el *scope* global. üö® Evitar su uso!

**let** ‚Üí Variable que podr√° se le podr√° reasignar un valor. Es de *scope* local, dentro de una funci√≥n por ejemplo.

**const** ‚Üí Variable de solo lectura. No es posible cambiar su valor. Su *scope* es local como el *let*. Usaremos siempre `const` por defecto a menos que sepamos que su valor va ha cambiar, ah√≠ usaremos `let`.

## **Tipos de datos**
---

String ‚Üí Secuencia de caracteres que representan un valor.
Number ‚Üí Valor num√©rico.
Boolean ‚Üí True o False.
Null ‚Üí Valor nulo. JS es *case-sensitive*. No es lo mismo Null, que NULL o null.
Undefined ‚Üí Valor sin definir.
Symbol ‚Üí Tipo de datos cuyos casos son √∫nicos e inmutables.
Object ‚Üí Objeto. Y puede contener m√°s variables en su interior.
Nan ‚Üí Not A Number

## **typeOf**
---
El operador `typeOf`devuelve el tipo de dato del operando.
La llamada a `typeOf x` devuelve una cadena con el nombre del tipo:
```js
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "hola" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"

typeof null // "object"

typeof alert // "function"

```
## **Cambiar contenido HTML con getElementById()**
---

getElementById() ‚Üí El siguiente ejemplo "busca" un elemento HTML (con id="demo") y cambia el contenido del elemento (innerHTML) a "Hello JavaScript": 

`document.getElementById("demo").innerHTML = "Hello JavaScript";`

```js
<p id="demo">JavaScript can change HTML content.</p>

<button type="button" onclick='document.getElementById("demo").innerHTML = "Hello JavaScript!"'>Click Me!</button>

```
![getElementById](./img/getElementById_01.png)

## **for**
---
Los *loops*, los necesitamos para crear un bucle tanta veces como queramos. Es habitual repetir acciones y de ah√≠ los *loops*.

```js
for (inicio; condici√≥n; incremento){
    // instrucci√≥n
}
```
**inicio** ‚Üí √âs una variable declarada que har√° de contador.

**condici√≥n** ‚Üí El *loop* se ejecuta mientras la condici√≥n se cumple.Determinar√° el n√∫mero de veces que se ejecuta.

**incremento** ‚Üí Actualiza el valor incrementando o reduciendo el contador.

**intrucci√≥n** ‚Üí Mientras la *condici√≥n* sea `true`, se ejecutar√° la *intrucci√≥n*.



```js
for (let i = 0; i < 100; i++){
  console.log('hello world!')
}
```
```js
let alumnos = ['Pepe', 'Paco', 'Ana', 'Luisa', 'Juan'];
let contenido = "Lista de alumnos:\n";

for (let index = 0; index < alumnos.length; index++) {
    contenido += `${index} ${alumnos[index]} \n`;
};

console.log(contenido);
/*
Lista de alumnos:
0  Pepe 
1  Paco 
2  Ana 
3  Luisa 
4  Juan 
*/
```

```js
// Sumar los valores del 1 al 10
let suma = 0
for (let i = 1; i <= 10; i++) {
    suma += i
}
console.log(`La suma de los n√∫meros del 1 al 10 es: ${suma}`) // 55
```

## **while**
---
Mientras la condici√≥n `condition` sea verdadera, el c√≥digo del cuerpo del bucle ser√° ejecutado.

```js
while (condition) {
  // C√≥digo
  // Llamada "cuerpo del bucle"
}
```

Por ejemplo, el bucle siguiente imprime `i` mientras se cumpla `i < 3`:

```js
let i = 0;
while (i < 3) { // Muestra 0, luego 1, luego 2
  alert( i );
  i++;
}
```

## **do while**
---
Similar a `while` solo que nos aseguramos que almenos de ejecute una vez.
```js
do {
  // cuerpo del bucle
} while (condition);
```

```js
let counter = 0

do {
    console.log('hello world!')
    counter++
} while (counter < 10) // Muestra 10 mensajes de "hello world!"
```
## **forEach**
----
`forEach` es un m√©todo de **array**, muy com√∫n, y sirve para recorrer un array sin escribir una estructura.
A menudo te ver√°s con la necesidad de iterar a trav√©s de una colecci√≥n de *arrays* y ejecutar un m√©todo *callback* por cada una de las iteraciones. Y para realizarlo hay un m√©todo muy √∫til: el m√©todo `forEach()`.

La funci√≥n *callback* puede recibir tres par√°metros.

- El elemento actual: Este es el elemento del arreglo por el cual se est√° haciendo la iteraci√≥n.
- Su √≠ndice: Este es el √≠ndice de la posici√≥n que tiene el elemento dentro del array.
- El array objetivo: Este es el array por el cual se est√° haciendo la iteraci√≥n.

üö® Con `forEach` **NO** puedes terminar el bucle con la instrucci√≥n `break`.

```js
let alumnos = ['Pep', 'Cesc', 'Anna', 'Lluisa', 'Joan'];
let content = "Listado de alumnos:\n";

alumnos.forEach(function(alumno, position) {
    content += `${position} ${alumno} \n`;
})

console.log(content);

/*
Listado de alumnos:
0  Pep 
1  Cesc 
2  Anna 
3  Lluisa 
4  Joan 
*/
```
```js
let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],

  showList() {
    this.students.forEach(
      student => console.log(this.title + ': ' + student)
    );
  }
};

group.showList();

/* 
"Our Group: John"
"Our Group: Pete"
"Our Group: Alice"
*/
```

```js
let numeros = [3, 6, 8, 10, 12]
let impar = 3;

numeros.forEach(function(numero) {
    if (numero === impar) {
        numeros.shift() // 3 ser√° borrado del arreglo
    }
})

console.log(numeros);

[6, 8, 10, 12] // Todos son pares!
```
En el siguiente ejemplo, vamos a ejecutar la funci√≥n  `pasarLista` por cada  uno de los estudiantes por los que se recorre el bucle dentro del array. La funci√≥n `pasarLista` solamente registra en la consola un *string* perteneciente a cada uno de los estudiantes.
```js
nombres = ["Anna", "Alicia", "Quim", "Guido", "Eva"]

function pasarLista(nombre, indice) {
    console.log(`Est√° el numero de estudiante ${indice + 1}  -${nombre} - presente? S√≠!`)
    ;}

numeros.forEach((nombre, indice) => pasarLista(nombre, indice));


/*
"Est√° el n√∫mero de estudiante 1  - Anna presente? S√≠!"
"Est√° el n√∫mero de estudiante 2  - Alicia presente? S√≠!"
"Est√° el n√∫mero de estudiante 3  - Quim presente? S√≠!"
"Est√° el n√∫mero de estudiante 4  - Guido presente? S√≠!"
"Est√° el n√∫mero de estudiante 5  - Eva presente? S√≠!"
*/
```
## **for of**
----
`for...of` es otro m√©todo de iterar arrays. En este caso, no tenemos acceso al n√∫mero de veces que hemos iterado, s√≥lo al valor de cada elemento del array.
```js
let fruits = ["Apple", "Orange", "Plum"];

for (let fruit of fruits) {
  console.log( fruit );
}

/*
"Apple"
"Orange"
"Plum"
*/

```
## **for in**
----
`For...in` es un m√©todo en este caso para iterar objetos. Crear√° una variable que ser√° la key de cada propiedad del objeto.

```js
let film = {title: 'El padrino', director: 'Francis Ford Coppola', year: 1972, score: 9}

for (let key in film) {
    console.log(`La key -> ${key} \nEl valor -> ${film[key]} `)
};

/*
La key -> title 
El valor -> El padrino 
La key -> director 
El valor -> Francis Ford Coppola 
La key -> year 
El valor -> 1972 
La key -> score 
El valor -> 9 
*/
```

## **break**
---
Normalmente, un loop contin√∫a mientras la condici√≥n es truey se detendr√° el bucle cuando la condici√≥n sea false.

Pero podemos forzar que se acabe el bucle utilizando la palabra `break`.

```js
let sum = 0;

while (true) {

  let value = Number(prompt("Enter a number", ''));

  if (!value) break;

  sum += value;

}
console.log( 'Sum: ' + sum );
```
## **Arrays**
---
Estructura de datos que nos permite almacenar m√∫ltiples valores en una misma estructura. Parecido a una lista. Se separa con `,` (comas)

Chuleta JavaScript - Array [link](https://www.tutorialesprogramacionya.com/herramientas/chuletajs/chuletamasejemplo.html#array) ‚Üê üñ± *Click derecho - Abrir v√≠nculo en una pesta√±a nueva.*

```js
const miArray = [ 'Laia', 4 ];
console.log(miArray); // [ 'Laia', 4 ]

const estudiantes = [ 'Pol', 'Anna', 'Joan', '√àlia' ];
console.log(estudiantes); // [ 'Pol', 'Anna', 'Joan', '√àlia' ]

const notas = [ 95, 67, 89, 56 ];
console.log(notas); // [ 95, 67, 89, 56 ]
```

### Array anidados

```js
const unNombre = [[], []];
```
```js
const listaEstudiantes = [['Daniel', 95],['Carmen', 97]];
console.log(listaEstudiantes) // [ [ 'Daniel', 95 ], [ 'Carmen', 97 ] ]
```
### Cambiar el valor de un Array

Para cambiar un valor dentro de una **array** se hace como si de una variable se trat√°ra.

```js
const miArray = [ 10, 20, 30 ];
miArray[1] = 'Hola'; // <- Le damos el valor 'Hola' a la posici√≥n 1, que de inicio ten√≠a 20.

console.log(miArray); // [ 10, 'Hola', 30 ]
```
Y podemos anidar Arrays en una posici√≥n.

```js
const miArray = [ 10, 20, 30 ];
miArray[1] = [ 1, 2, 3 ];

console.log(miArray); // [ 10, [ 1, 2, 3 ], 30 ]
```
### Acceso a Arrays multidimensionales (anidados)
Arrays que contienen otros Arrays.
```js
const miArray = [ [ 1, 2, 3 ],[4, 5, 6 ], [7, 8, 9 ] ];

/*
Array           [ [ 1, 2, 3 ],[4, 5, 6 ], [7, 8, 9 ] ]
√çndices:               0          1           2
√çndice internos:    0  1  2    0  1  2     0  1  2
*/

console.log(miArray[1]); // [ 4, 5, 6 ]

/* Para acceder al n√∫mero 6 del Array en el √≠ndice 1 
o a la posici√≥n 0 del √≠ndice 2
*/

console.log(miArray[1][2]); // 6
console.log(miArray[2][0]); // 7
```

## **M√©todos de Array**
---
**PUSH** ‚Üí A√±ade uno o m√°s elementos **al final** del array y retorna el n√∫mero de elementos del array.
```js
const array1 = ['chirimoyas', 'manzanas', 'peras', 'sandias']
array1.push('naranjas')
console.log(array1) // [ 'chirimoyas', 'manzanas', 'peras', 'sandias', 'naranjas' ]

array1.push('limones', 'ciruelas')
console.log(array1) // [ 'chirimoyas', 'manzanas', 'peras', 'sandias', 'naranjas', 'limones', 'ciruelas' ]

const tamano = array1.push('kiwis') // OJO AQU√ç. 
console.log(tamano) // 8

const array2 = [1, 2, 3, 4, 5]
array2.push(10)
console.log(array2) // [ 1, 2, 3, 4, 5, 10 ]
```
**POP** ‚Üí Elimina el √∫ltimo elemento del array y lo retorna. Si el array esta vac√≠o luego retorna undefined.
```js
const miArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
const ultimo = miArray.pop()
console.log(ultimo) // 10
console.log(miArray) // [1,2,3,4,5,6,7,8,9]
console.log(miArray.pop()) // 9 
console.log(miArray.length) // 8 
```
**SHIFT** ‚Üí Elimina el primer elemento del array y lo retorna. Si el array esta vac√≠o luego retorna undefined.

```js
let fruits = ["Apple", "Orange", "Pear"];

let firstFruit = fruits.shift(); // Apple

console.log( fruits ); // Orange, Pear
```

**UNSHIFT** ‚Üí A√±ade uno o m√°s elementos al inicio del array y retorna el n√∫mero de elementos del array.
```js
const myArray = [1, 2, 3]
myArray.unshift(10, 20, 30)
console.log(myArray) // [10,20,30,1,2,3]

const cantElementos = myArray.unshift(100)
console.log(cantElementos) // 7
console.log(myArray) // [100,10,20,30,1,2,3]
```
**FIND** ‚Üí Retorna el primer elemento del array que cumpla con la condici√≥n de la funci√≥n que se pasa como par√°metro.

```js
const frutas = [{
    nombre: 'Manzana',
    calorias: 68,
}, {
    nombre: 'Pera',
    calorias: 57,
}, {
    nombre: 'Sandia',
    calorias: 30,
}, {
    nombre: 'Melon',
    calorias: 36,
}, {
    nombre: 'Chirimoya',
    calorias: 40,
}, {
    nombre: 'Naranja',
    calorias: 40,
}]
console.log(frutas.find(fruta => fruta.nombre === 'Manzana')) // {nombre: 'Manzana', calorias: 68}
console.log(frutas.find(fruta => fruta.calorias === 40)) // {nombre: 'Chirimoya', calorias: 40}
```
**FOREACH** ‚Üí Otra vez. Ejecuta la funci√≥n para cada elemento del array en forma ascendente. La funci√≥n recibe el valor, el √≠ndice y el arreglo.

```js
const colores=["rojo","verde","azul"]
colores.forEach((elemento,indice,array)=>{
    console.log(elemento,indice,array)
})
colores.forEach(elemento=>{
    console.log(elemento) // "rojo" "verde" "azul"
})
colores.forEach((elemento,indice,array)=>{
    array[indice]="amarillo"
})
console.log(colores) // ["amarillo", "amarillo", "amarillo"]
```
**MAP** ‚Üí El m√©todo `map` aplica una funci√≥n a cada elemento del array y retorna un nuevo array con el resultado.

- No modifica el array original
- **Retorna un nuevo array** con los resultados de aplicar la funci√≥n que se pasa como par√°metro a cada elemento del array.


SINTAXIS

```js
arr.map(callback(element, index, array));
```
```js
const numbers = [1, 5, 10, 15];
const resultMultiplyTwo = numbers.map(function(num) {
   return num * 2;
});

console.log(resultMultiplyTwo)// [2, 10, 20, 30]
console.log(numbers) // [1, 5, 10, 15]
```

```js
const numeros = [1, 4, 9];
const raizCuadrada = numeros.map(function(num) {
    return Math.sqrt(num);
});
// raizCuadrada es ahora [1, 2, 3]
// numeros siguen siendo [1, 4, 9]
```

O as√≠, con `arrow function`

```js
const numeros = [1, 4, 9];
const raizCuadrada = numeros.map((num) => Math.sqrt(num));

console.log(raizCuadrada); // [1, 2, 3]
console.log(numeros); // [1, 4, 9]
```

Otro ejemplo: Esto a√±ade el sufijo *man* a cada *prefijo*

```js
let prefijos = ["super", "spider", "ant", "iron"]
let sufijo = "man";

let nombresCompletos = prefijos.map(prefijo => prefijo + sufijo);

console.log(nombresCompletos);

// ["superman", "spiderman", "antman", "ironman"]
```

## **Objetos**
---
En JavaScript todo on objetos.

 ```js
let annualSalary = 30000
let months = 12

function getSalary (annualSalary, months) {
    return annualSalary / months
    
}

console.log(getSalary(annualSalary, months)) // 2500

// Recordatorio: Hace referencia a las variables. No tiene que coindicir con los nombre de los par√°matros de la funci√≥n.

 ```

Ejemplo de implementaci√≥n OOP

```js
let employee = {
    annualSalary: 30000,
    months: 12,
    getSalary: function getSalary () {
        return this.annualSalary / this.months
    }
}
```





## **Operador Rest y Spread**
---

El operador **Rest** disponible en (JS ES6) sirve para recibir cualquier n√∫mero de par√°metros en una funci√≥n en forma array.

Si lo declaramos en los *argumetos* de vuelve un array.
```js
function miFuncion(...args) { // args o cualquier otro nombre.
  console.log(args);
}

miFuncion(1, 2, 3, 4); // [1, 2, 3, 4]

```
O as√≠:

```js
const miFuncion = (...args) => console.log(args);


miFuncion(1, 2, 3, 4);  // [1, 2, 3, 4]

```
Si lo declaramos en la funci√≥n, realiza acciones dentro del array. Y descompone el array en sus elementos individuales y asignarlos en orden a los par√°metros. Aplicado as√≠ este operador se llama **Spread**
```js
const numeros = [1, 2, 3];

const sumar = (x, y, z) => x + y + z;

// sumar(numeros[0],numeros[1],numeros[2] ); // <- As√≠ ser√≠a la operaci√≥n sin **rest**

console.log(sumar(...numeros)); // 6

```


## **Funciones**
---
`function` *nombreDeLaFuncion* seguido de `()`. Y entre las *curly braces* `{ }` pondremos las **instrucciones**.

Un a funci√≥n es JavaScript es un OBJETO, de hecho, TODO en JS es un OBJETO y podemos acceder a ellos como tal.

```js
function sayHi() {
  console.log('Hello!')
}

sayHi() // "Hello!"

```

### Devuelven valores: `return`
Una funci√≥n puede devolver un valor al c√≥digo de llamada como resultado.

El ejemplo m√°s simple ser√≠a una funci√≥n que suma dos valores:

```js
function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3
```
```js
function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('¬øTienes permiso de tus padres?');
  }
}

let age = prompt('¬øQu√© edad tienes?', 18);

if ( checkAge(age) ) {
  alert( 'Acceso otorgado' );
} else {
  alert( 'Acceso denegado' );
}
```


üö® Todo el c√≥digo despu√©s del `return`, no se ejecutar√°. El `return` pone fin a la acci√≥n de la funci√≥n.
```js
const value1 = 4
const value2 = 4

function average(){ 

   	let result
   	result = (value1 + value2) / 2 
   	return result
    result = 0 // <- Esta l√≠nea nunca se ejecutar√°.
}

const averageResult = average()
averageResult // 4
```

Para llamar a una **funci√≥n anidada**, se usa el doble `()()`, de lo contrario no devuelve el valor que hay dentro.

```js
const a ='¬°Hey! '
function global() {
  const b = '¬øQu√©'
  
  function local() {
    const c = ' tal?'
    return a + b + c
  }
  
  return local
}

global()() // '¬°Hey! ¬øQu√© tal?'
```

## **Clousure**

Un **clousure** es una funci√≥n autoejecutable que encapsula una serie de variables y deficiones locales que √∫nicamente ser√°n accesibles si son devueltas con el operador `return`. Esto permite tener, en cierto modo, *variables privadas*. O mejor dicho, menos accesibles desde fuera. Se usa cada vez menos desde la llegada de ES6 (ECMAScript v6)
Se usa con gui√≥n bajo `_abc` por convenci√≥n. Hace referencia a la variable que no es accesible desde fuera.
```js
const miContador = function(){
  let _contador = 0
  
  function incrementar() {
    return _contador++
  }
  function decrementar() {
    return _contador--
  }
  function valor(){
    return _contador
  }
}
```
Para que funcione esto hay que englobar la funci√≥n principal `miContador ` entre `()`, y para que se ejecute, colocamos otro juego de  `()` al final.

```js
const miContador = (function(){
  let _contador = 0
  
  function incrementar() {
    return _contador++
  }
  
  function decrementar() {
    return _contador--
  }
  
  function valor(){
    return _contador
  }
  
  return {
  incrementar,
  decrementar,
  valor
}
})()

miContador.valor() // 0
miContador.incrementar() //0
miContador.valor() // 1
```
## **Asincron√≠as**

### Cargar un SCRIPT externo.

La funci√≥n `loadScript(src)`, que carga un c√≥digo script `src` dado.

Esto se llama *programaci√≥n asincr√≥nica ‚Äúbasado en callback‚Äù*. Una funci√≥n que hace algo de forma asincr√≥nica deber√≠a aceptar un argumento de callback donde ponemos la funci√≥n por ejecutar despu√©s de que se complete.

```js
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;
  script.onload = () => callback(script);
  document.head.append(script);
}

loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {
  alert(`Genial, el script ${script.src} est√° cargado`);
  alert( _ ); // _ es una funci√≥n declarada en el script cargado
});
```

Ejemplo mejorado de `loadScript` con funci√≥n de validaci√≥n.
Para una carga exitosa llama a `callback(null, script)` y de lo contrario a `callback(error)`.

```js
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Error de carga de script con ${src}`));

  document.head.append(script);
}
```
### RESOLVE y REJECT

Los argumentos **resolve** y **reject** son *callbacks* proporcionadas por el propio JavaScript. Nuestro c√≥digo solo est√° dentro del ejecutor.

Cuando el ejecutor, m√°s tarde o m√°s temprano, eso no importa, obtiene el resultado, debe llamar a una de estos callbacks:

- `resolve(value)` ‚Üí Si el trabajo finaliz√≥ con √©xito, con el resultado `value`.

- `reject(error)` ‚Üí Si ocurri√≥ un error, error es el objeto `error`.

M√©todo antiguo

```js
const datos = [
  {
    id: 1,
    title: 'Iron Man',
    year: 2008
  },
  {
    id: 2,
    title: 'Spiderman',
    year: 2017
  },
  {
    id: 3,
    title: 'Avengers: Endgame',
    year: 2019
  }
]

//const getDatos = () => {
//return datos
//}
const getDatos = () => {
  return new Promise ((resolve, reject) => {
      setTimeout (() => {
        resolve (datos)
  }, 1500) // Tiempo de retardo que le damos a la funcion con setTimeout para simular un retraso de tiempo. En milisegundos.
  })
}

getDatos()
  .then((datos) => console.log(datos))



/*
Despu√©s de 1,5seg devuelve esto:
[
  { id: 1, title: 'Iron Man', year: 2008 },
  { id: 2, title: 'Spiderman', year: 2017 },
  { id: 3, title: 'Avengers: Endgame', year: 2019 }
]
*/  
```
M√©todo moderno. Con `ASYNC AWAIT`. Es el m√°s sencillo y utilizado en lugar de la promesas.

```js
const datos = [
  {
    id: 1,
    title: 'Iron Man',
    year: 2008
  },
  {
    id: 2,
    title: 'Spiderman',
    year: 2017
  },
  {
    id: 3,
    title: 'Avengers: Endgame',
    year: 2019
  }
]

const getDatos = () => {
  return new Promise ((resolve, reject) => {
      setTimeout (() => {
        resolve (datos)
  }, 1500) // Tiempo de retardo que le damos a la funcion con setTimeout para simular un retraso de tiempo. En milisegundos.
  })
}

async function fetchingData () {
  const datosFetched = await getDatos()
  onsole.log(datosFetched)
}

fetchingData()


/*
Despu√©s de 1,5seg devuelve esto:
[
  { id: 1, title: 'Iron Man', year: 2008 },
  { id: 2, title: 'Spiderman', year: 2017 },
  { id: 3, title: 'Avengers: Endgame', year: 2019 }
]
*/  
```
Y lo mismo, pero imprimiendo los objetos por separado, uno a uno.

```js
const datos = [
  {
    id: 1,
    title: 'Iron Man',
    year: 2008
  },
  {
    id: 2,
    title: 'Spiderman',
    year: 2017
  },
  {
    id: 3,
    title: 'Avengers: Endgame',
    year: 2019
  }
]

const getDatos = (i) => {
  return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve(datos[i])
      }, 1500) // Tiempo de retardo que le damos a la funcion con setTimeout para simular un retraso de tiempo. En milisegundos.
  })
}

(async () => {
  for (let i = 0; i < datos.length; i++) {

    console.log(await getDatos(i));
  }
})()
```
Otro ejemplo ASYNC AWAIT (simulando consulta en **MongoDB**)

```js
async function requestHandler(req, res) {
  
  try { // Intenta esto esto, y si no...(catch)

    const user = await User.findById(req.userId);
    const tasks = await Tasks.findById(user.tasksId);
    tasks.completed = true;
    await tasks.save();
    res.send('Task completed');

  }

  catch(err) { // Y si no... muestra el error

    res.send(err);

  }

}
```

## **Arrow Functions**
---
Las *arrow functions* permiten simplificar las funciones mejorando su expresividad.

Hay varias formas de crear una *arrow function*. Por ejemplo, podemos crear una *arrow function* sin necesidad de poner `()` despu√©s del `=` siempre y cuando la funci√≥n no necesite par√°metros o solo tenga uno.
Entonces, la siguiente funci√≥n:
```js
function saludar (){
  const nombre = 'Quim';
  console.log('Hola');
}
saludar(); // "¬°Hola Quim!"
```
Para crear una *arrow function*, primero quitamos la palabra `function` y como esta funci√≥n √∫nicamente tiene un par√°metro, podemos obviar los `()` y colocar la constante `nombre` seguida del s√≠mbolo de la `a.f`, que es este, `=>`.

üö® Si la `a.f` ocupa solo una l√≠nea, esta ya lleva impl√≠cito el `return`, por lo que no har√≠a falta escribirlo. Tambi√©n podemos omitir las `{ }`.

```js
const saludar = nombre => console.log(`¬°Hola ${nombre}!`);

saludar('Quim') // "¬°Hola Quim!"
```

```js
const sumar = function (a,b){
  return a + b;  
}

console.log(sumar(5,5)); // 10
```
Y aqu√≠ tenemos lo mismo con una `arrow function`
La funci√≥n tiene dos par√°metros, y en este caso s√≠ que debemos poner `()`, seguido de `=>` y la instrucci√≥n. Tampoco necesita `return` ni `{ }`.

```js
const sumar = (a,b) => a + b;

console.log(sumar(5,5)); // 10
```
üö® Con las funciones de flecha no hay vinculaci√≥n de `this`. Har√≠a referencia a `Window` 

M√°s ejemplos...

```js
const concatenarArrays = function(arr1, arr2) {
  return arr1.concat(arr2);
};

console.log(concatenarArrays([1, 2], [3, 4, 5])); // [ 1, 2, 3, 4, 5 ]
```
Versi√≥n `a.f`
```js
const concatenarArrays = (arr1, arr2) => arr1.concat(arr2);

console.log(concatenarArrays([1, 2], [3, 4, 5])); // [ 1, 2, 3, 4, 5 ]
```

Y cuando la funci√≥n ocupa varias l√≠neas funciona de la siguiente manera:
```js
const sumar = function(a, b) {
  let num = 6;
  return a + b + num;
}

console.log(sumar(1,1)); // 8

```
En `a.f`.
```js
const sumar = (a, b) => {
  let num = 6;
  return a + b + num;
}

console.log(sumar(1,1)); // 8
```
Tunear un valor por defecto es posible, *look at this* ‚¨á

```js
const incrementar = (num, valor = 1) => num + valor;

console.log(incrementar(5, 3)); // <- Aqu√≠ le pasamos el valor 3, como nuevo valor (que era 1) y el resultado es 8
```

### THEN y CATCH

Un objeto Promise sirve como enlace entre el ejecutor y las funciones consumidoras, que recibir√°n un resultado o un error. Las funciones de consumo pueden registrarse utilizando los m√©todos `.then` y `.catch`. La llamada `.catch(f)` es un an√°logo completo de `.then(null, f)`, es solo una abreviatura, se usa habitualmente para llamar al *Mensaje de Error*

SINTAXIS

```js
promise.then(
  function(result) { /* manejar un resultado exitoso */ },
  function(error) { /* manejar un error */ }
);
```

El primer argumento de `.then` es una funci√≥n que se ejecuta cuando se resuelve la promesa y recibe el resultado.

El segundo argumento de `.then` es una funci√≥n que se ejecuta cuando se rechaza la promesa y recibe el error.

Por ejemplo, aqu√≠ hay una reacci√≥n a una promesa resuelta con √©xito:
```js
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve("hecho!"), 1000);
});

// resolve ejecuta la primera funci√≥n en .then
promise.then(
  result => alert(result), // muestra "hecho!" despu√©s de 1 segundo
  error => alert(error) // no se ejecuta
);
```

## **Window**
---
Podemos utilizar el **objeto especial** `Window` para acceder directamente al √°mbito global del DOM independientemente de donde nos encontremos. Esto ocurre as√≠ porque las variables globales se almacenan dentro del objeto Window, es la ventana del navegador web.

```js
let a = 1;
console.log(a); // Aqu√≠ accedemos a la "a" global, que vale 1

function x() {
  console.log(a); // En esta l√≠nea el valor de "a" es 1
  a = 5; // Aqu√≠ creamos una variable "a" en el √°mbito anterior

  console.log(a); // Aqu√≠ el valor de "a" es 5 (a nivel de funci√≥n)
  console.log(window.a); // Aqu√≠ el valor de "a" es 5 (√°mbito global)
}

x(); // Aqu√≠ se ejecuta el c√≥digo de la funci√≥n x()
console.log(a); // En esta l√≠nea el valor de "a" es 5

```
## **Template literal**
---
Ejemplo:
```js
let name = "Quim";
alert( `Hola, tu nombre es ${"name"}.`); // Hola, tu nombre es Quim.
```

## **Convertir a STRING o NUMBER**
---
Escribimos String, Number para covertir valores.

```js
let value = true;
alert(typeof value); // boolean

value = String(value); // ahora value es el string "true"
alert(typeof value); // string
```

Nota:
Los string "afectados" por un operador l√≥gico ser√°n convertidos a n√∫meros.
```js
alert( "6" / "2" ); // 3, los strings son convertidos a n√∫meros
```
##

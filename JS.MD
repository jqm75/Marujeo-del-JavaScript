# ‚ö° Marujeo del JavaScript ‚ö°

## √çndice

 
  - [**Variables**](#variables)
  - [**Tipos de datos**](#tipos-de-datos)
  - [**typeOf**](#typeof)
  - [**Cambiar contenido HTML con getElementById()**](#cambiar-contenido-html-con-getelementbyid)
  - [**for**](#for)
  - [**while**](#while)
  - [**do while**](#do-while)
  - [**forEach**](#foreach)
  - [**for of**](#for-of)
  - [**for in**](#for-in)
  - [**break**](#break)
  - [**Arrays**](#array)
  - [**Objetos**](#objetos)
  - [**Operador Rest y Spread**](#operador-rest-y-spread)
  - [**Funciones**](#funciones)
  - [**Arrow Fuctions**](#arrow-functions)
  - [**Window**](#window)
  - [**Template literal**](#template-literal)
  - [**Convertir a STRING o NUMBER**](#convertir-a-string-o-number)
---




## **Variables**
---

Las variables son cajas, contenedores donde guardar datos y se pueden cambiar por otros. Es quiere decir que es **mutable**.
B√°sicamente hay de dos tipos: `let` y `const`. Tambi√©n existe `var`, que hay que evitar.

**var** ‚Üí Declara una variable en el *scope* global. üö® Evitar su uso!

**let** ‚Üí Variable que podr√° se le podr√° reasignar un valor. Es de *scope* local, dentro de una funci√≥n por ejemplo.

**const** ‚Üí Variable de solo lectura. No es posible cambiar su valor. Su *scope* es local como el *let*. Usaremos siempre `const` por defecto a menos que sepamos que su valor va ha cambiar, ah√≠ usaremos `let`.

## **Tipos de datos**
---

String ‚Üí Secuencia de caracteres que representan un valor.
Number ‚Üí Valor num√©rico.
Boolean ‚Üí True o False.
Null ‚Üí Valor nulo. JS es *case-sensitive*. No es lo mismo Null, que NULL o null.
Undefined ‚Üí Valor sin definir.
Symbol ‚Üí Tipo de datos cuyos casos son √∫nicos e inmutables.
Object ‚Üí Objeto. Y puede contener m√°s variables en su interior.
Nan ‚Üí Not A Number

## **typeOf**
---
El operador `typeOf`devuelve el tipo de dato del operando.
La llamada a `typeOf x` devuelve una cadena con el nombre del tipo:
```
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "hola" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"

typeof null // "object"

typeof alert // "function"

```
## **Cambiar contenido HTML con getElementById()**
---

getElementById() ‚Üí El siguiente ejemplo "busca" un elemento HTML (con id="demo") y cambia el contenido del elemento (innerHTML) a "Hello JavaScript": 

`document.getElementById("demo").innerHTML = "Hello JavaScript";`

```
<p id="demo">JavaScript can change HTML content.</p>

<button type="button" onclick='document.getElementById("demo").innerHTML = "Hello JavaScript!"'>Click Me!</button>

```
![getElementById](./img/getElementById_01.png)

## **for**
---
Los *loops*, los necesitamos para crear un bucle tanta veces como queramos. Es habitual repetir acciones y de ah√≠ los *loops*.

```
for (inicio; condici√≥n; incremento){
    // instrucci√≥n
}
```
**inicio** ‚Üí √âs una variable declarada que har√° de contador.

**condici√≥n** ‚Üí El *loop* se ejecuta mientras la condici√≥n se cumple.Determinar√° el n√∫mero de veces que se ejecuta.

**incremento** ‚Üí Actualiza el valor incrementando o reduciendo el contador.

**intrucci√≥n** ‚Üí Mientras la *condici√≥n* sea `true`, se ejecutar√° la *intrucci√≥n*.



```
for (let i = 0; i < 100; i++){
  console.log('hello world!')
}
```
```
let alumnos = ['Pepe', 'Paco', 'Ana', 'Luisa', 'Juan'];
let contenido = "Lista de alumnos:\n";

for (let index = 0; index < alumnos.length; index++) {
    contenido += `${index} ${alumnos[index]} \n`;
};

console.log(contenido);
/*
Lista de alumnos:
0  Pepe 
1  Paco 
2  Ana 
3  Luisa 
4  Juan 
*/
```

```
// Sumar los valores del 1 al 10
let suma = 0
for (let i = 1; i <= 10; i++) {
    suma += i
}
console.log(`La suma de los n√∫meros del 1 al 10 es: ${suma}`) // 55
```

## **while**
---
Mientras la condici√≥n `condition` sea verdadera, el c√≥digo del cuerpo del bucle ser√° ejecutado.

```
while (condition) {
  // C√≥digo
  // Llamada "cuerpo del bucle"
}
```

Por ejemplo, el bucle siguiente imprime `i` mientras se cumpla `i < 3`:

```
let i = 0;
while (i < 3) { // Muestra 0, luego 1, luego 2
  alert( i );
  i++;
}
```

## **do while**
---
Similar a `while` solo que nos aseguramos que almenos de ejecute una vez.
```
do {
  // cuerpo del bucle
} while (condition);
```

```
let counter = 0

do {
    console.log('hello world!')
    counter++
} while (counter < 10) // Muestra 10 mensajes de "hello world!"
```
## **forEach**
----
`forEach` es un m√©todo de **array**, muy com√∫n, y sirve para recorrer un array sin escribir una estructura.
A menudo te ver√°s con la necesidad de iterar a trav√©s de una colecci√≥n de *arrays* y ejecutar un m√©todo *callback* por cada una de las iteraciones. Y para realizarlo hay un m√©todo muy √∫til: el m√©todo `forEach()`.

La funci√≥n *callback* puede recibir tres par√°metros.

- El elemento actual: Este es el elemento del arreglo por el cual se est√° haciendo la iteraci√≥n.
- Su √≠ndice: Este es el √≠ndice de la posici√≥n que tiene el elemento dentro del array.
- El array objetivo: Este es el array por el cual se est√° haciendo la iteraci√≥n.

üö® Con `forEach` **NO** puedes terminar el bucle con la instrucci√≥n `break`.

```
let alumnos = ['Pep', 'Cesc', 'Anna', 'Lluisa', 'Joan'];
let content = "Listado de alumnos:\n";

alumnos.forEach(function(alumno, position) {
    content += `${position} ${alumno} \n`;
})

console.log(content);

/*
Listado de alumnos:
0  Pep 
1  Cesc 
2  Anna 
3  Lluisa 
4  Joan 
*/
```
```
let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],

  showList() {
    this.students.forEach(
      student => console.log(this.title + ': ' + student)
    );
  }
};

group.showList();

/* 
"Our Group: John"
"Our Group: Pete"
"Our Group: Alice"
*/
```

```
let numeros = [3, 6, 8, 10, 12]
let impar = 3;

numeros.forEach(function(numero) {
    if (numero === impar) {
        numeros.shift() // 3 ser√° borrado del arreglo
    }
})

console.log(numeros);

[6, 8, 10, 12] // Todos son pares!
```
En el siguiente ejemplo, vamos a ejecutar la funci√≥n  `pasarLista` por cada  uno de los estudiantes por los que se recorre el bucle dentro del array. La funci√≥n `pasarLista` solamente registra en la consola un *string* perteneciente a cada uno de los estudiantes.
```
nombres = ["Anna", "Alicia", "Quim", "Guido", "Eva"]

function pasarLista(nombre, indice) {
    console.log(`Est√° el numero de estudiante ${indice + 1}  -${nombre} - presente? S√≠!`)
    ;}

numeros.forEach((nombre, indice) => pasarLista(nombre, indice));


/*
"Est√° el n√∫mero de estudiante 1  - Anna presente? S√≠!"
"Est√° el n√∫mero de estudiante 2  - Alicia presente? S√≠!"
"Est√° el n√∫mero de estudiante 3  - Quim presente? S√≠!"
"Est√° el n√∫mero de estudiante 4  - Guido presente? S√≠!"
"Est√° el n√∫mero de estudiante 5  - Eva presente? S√≠!"
*/
```
## **for of**
----
`for...of` es otro m√©todo de iterar arrays. En este caso, no tenemos acceso al n√∫mero de veces que hemos iterado, s√≥lo al valor de cada elemento del array.
```
let fruits = ["Apple", "Orange", "Plum"];

for (let fruit of fruits) {
  console.log( fruit );
}

/*
"Apple"
"Orange"
"Plum"
*/

```
## **for in**
----
`For...in` es un m√©todo en este caso para iterar objetos. Crear√° una variable que ser√° la key de cada propiedad del objeto.

```
let film = {title: 'El padrino', director: 'Francis Ford Coppola', year: 1972, score: 9}

for (let key in film) {
    console.log(`La key -> ${key} \nEl valor -> ${film[key]} `)
};

/*
La key -> title 
El valor -> El padrino 
La key -> director 
El valor -> Francis Ford Coppola 
La key -> year 
El valor -> 1972 
La key -> score 
El valor -> 9 
*/
```

## **break**
---
Normalmente, un loop contin√∫a mientras la condici√≥n es truey se detendr√° el bucle cuando la condici√≥n sea false.

Pero podemos forzar que se acabe el bucle utilizando la palabra `break`.

```
let sum = 0;

while (true) {

  let value = Number(prompt("Enter a number", ''));

  if (!value) break;

  sum += value;

}
console.log( 'Sum: ' + sum );
```
## **Arrays**
---
Estructura de datos que nos permite almacenar m√∫ltiples valores en una misma estructura. Parecido a una lista. Se separa con `,` (comas)

Chuleta JavaScript - Array [link](https://www.tutorialesprogramacionya.com/herramientas/chuletajs/chuletamasejemplo.html#array) ‚Üê *Click derecho - Abrir v√≠nculo en una pesta√±a nueva.*
<https://www.tutorialesprogramacionya.com/herramientas/chuletajs/chuletamasejemplo.html#array>

```
const miArray = [ 'Laia', 4 ];
console.log(miArray); // [ 'Laia', 4 ]

const estudiantes = [ 'Pol', 'Anna', 'Joan', '√àlia' ];
console.log(estudiantes); // [ 'Pol', 'Anna', 'Joan', '√àlia' ]

const notas = [ 95, 67, 89, 56 ];
console.log(notas); // [ 95, 67, 89, 56 ]
```

### Array anidados

```
const unNombre = [[], []];
```
```
const listaEstudiantes = [['Daniel', 95],['Carmen', 97]];
console.log(listaEstudiantes) // [ [ 'Daniel', 95 ], [ 'Carmen', 97 ] ]
```
### Cambiar el valor de un Array

Para cambiar un valor dentro de una **array** se hace como si de una variable se trat√°ra.

```
const miArray = [ 10, 20, 30 ];
miArray[1] = 'Hola'; // <- Le damos el valor 'Hola' a la posici√≥n 1, que de inicio ten√≠a 20.

console.log(miArray); // [ 10, 'Hola', 30 ]
```
Y podemos anidar Arrays en una posici√≥n.

```
const miArray = [ 10, 20, 30 ];
miArray[1] = [1, 2, 3];

console.log(miArray); // [ 10, [ 1, 2, 3 ], 30 ]
```
### Acceso a Arrays multidimensionales (anidados)


## **Objetos**
---
## **Operador Rest y Spread**
---

El operador **Rest** disponible en (JS ES6) sirve para recibir cualquier n√∫mero de par√°metros en una funci√≥n en forma array.

Si lo declaramos en los *argumetos* de vuelve un array.
```
function miFuncion(...args) { // args o cualquier otro nombre.
  console.log(args);
}

miFuncion(1, 2, 3, 4); // [1, 2, 3, 4]

```
O as√≠:

```
const miFuncion = (...args) => console.log(args);


miFuncion(1, 2, 3, 4);  // [1, 2, 3, 4]

```
Si lo declaramos en la funci√≥n, realiza acciones dentro del array. Y los descompone el array en sus elementos individuales y asignarlos en orden a los par√°metros. Aplicado as√≥ este operador se llama **Spread**
```
const numeros = [1, 2, 3];

const sumar = (x, y, z) => x + y + z;

// sumar(numeros[0],numeros[1],numeros[2] ); // <- As√≠ ser√≠a la operaci√≥n sin **rest**

console.log(sumar(...numeros)); // 6

```


## **Funciones**
---
`function` *nombreDeLaFuncion* seguido de `()`. Y entre las *curly braces* `{ }` pondremos las **instrucciones**.

```
function sayHi() {
  console.log('Hello!')
}

sayHi() // "Hello!"

```

### Devuelven valores: `return`
Una funci√≥n puede devolver un valor al c√≥digo de llamada como resultado.

El ejemplo m√°s simple ser√≠a una funci√≥n que suma dos valores:

```
function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3
```
```
function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('¬øTienes permiso de tus padres?');
  }
}

let age = prompt('¬øQu√© edad tienes?', 18);

if ( checkAge(age) ) {
  alert( 'Acceso otorgado' );
} else {
  alert( 'Acceso denegado' );
}
```


üö® Todo el c√≥digo despu√©s del `return`, no se ejecutar√°. El `return` pone fin a la acci√≥n de la funci√≥n.
```
const value1 = 4
const value2 = 4

function average(){ 

   	let result
   	result = (value1 + value2) / 2 
   	return result
    result = 0 // <- Esta l√≠nea nunca se ejecutar√°.
}

const averageResult = average()
averageResult // 4
```
## **Arrow Functions**
---
Las *arrow functions* permiten simplificar las funciones mejorando su expresividad.

Hay varias formas de crear una *arrow function*. Por ejemplo, podemos crear una *arrow function* sin necesidad de poner `()` despu√©s del `=` siempre y cuando la funci√≥n no necesite par√°metros o solo tenga uno.
Entonces, la siguiente funci√≥n:
```
function saludar (){
  const nombre = 'Quim';
  console.log('Hola');
}
saludar(); // "¬°Hola Quim!"
```
Para crear una *arrow function*, primero quitamos la palabra `function` y como esta funci√≥n √∫nicamente tiene un par√°metro, podemos obviar los `()` y colocar la constante `nombre` seguida del s√≠mbolo de la `a.f`, que es este, `=>`.

üö® Si la `a.f` ocupa solo una l√≠nea, esta ya lleva impl√≠cito el `return`, por lo que no har√≠a falta escribirlo. Tambi√©n podemos omitir las `{ }`.

```
const saludar = nombre => console.log(`¬°Hola ${nombre}!`);

saludar('Quim') // "¬°Hola Quim!"
```

```
const sumar = function (a,b){
  return a + b;  
}

console.log(sumar(5,5)); // 10
```
Y aqu√≠ tenemos lo mismo con una `arrow function`
La funci√≥n tiene dos par√°metros, y en este caso s√≠ que debemos poner `()`, seguido de `=>` y la instrucci√≥n. Tampoco necesita `return` ni `{ }`.

```
const sumar = (a,b) => a + b;

console.log(sumar(5,5)); // 10
```
üö® Con las funciones de flecha no hay vinculaci√≥n de `this`. Har√≠a referencia a `Window` 

M√°s ejemplos...

```
const concatenarArrays = function(arr1, arr2) {
  return arr1.concat(arr2);
};

console.log(concatenarArrays([1, 2], [3, 4, 5])); // [ 1, 2, 3, 4, 5 ]
```
Versi√≥n `a.f`
```
const concatenarArrays = (arr1, arr2) => arr1.concat(arr2);

console.log(concatenarArrays([1, 2], [3, 4, 5])); // [ 1, 2, 3, 4, 5 ]
```

Y cuando la funci√≥n ocupa varias l√≠neas funciona de la siguiente manera:
```
const sumar = function(a, b) {
  let num = 6;
  return a + b + num;
}

console.log(sumar(1,1)); // 8

```
En `a.f`.
```
const sumar = (a, b) => {
  let num = 6;
  return a + b + num;
}

console.log(sumar(1,1)); // 8
```
Tunear un valor por defecto es posible, *look at this* ‚¨á

```
const incrementar = (num, valor = 1) => num + valor;

console.log(incrementar(5, 3)); // <- Aqu√≠ le pasamos el valor 3, como nuevo valor (que era 1) y el resultado es 8
```
## **Window**
---
Podemos utilizar el **objeto especial** `Window` para acceder directamente al √°mbito global del DOM independientemente de donde nos encontremos. Esto ocurre as√≠ porque las variables globales se almacenan dentro del objeto Window, es la ventana del navegador web.

```
let a = 1;
console.log(a); // Aqu√≠ accedemos a la "a" global, que vale 1

function x() {
  console.log(a); // En esta l√≠nea el valor de "a" es 1
  a = 5; // Aqu√≠ creamos una variable "a" en el √°mbito anterior

  console.log(a); // Aqu√≠ el valor de "a" es 5 (a nivel de funci√≥n)
  console.log(window.a); // Aqu√≠ el valor de "a" es 5 (√°mbito global)
}

x(); // Aqu√≠ se ejecuta el c√≥digo de la funci√≥n x()
console.log(a); // En esta l√≠nea el valor de "a" es 5

```
## **Template literal**
---
Ejemplo:
```
let name = "Quim";
alert( `Hola, tu nombre es ${"name"}.`); // Hola, tu nombre es Quim.
```

## **Convertir a STRING o NUMBER**
---
Escribimos String, Number para covertir valores.

```
let value = true;
alert(typeof value); // boolean

value = String(value); // ahora value es el string "true"
alert(typeof value); // string
```

Nota:
Los string "afectados" por un operador l√≥gico ser√°n convertidos a n√∫meros.
```
alert( "6" / "2" ); // 3, los strings son convertidos a n√∫meros
```

##
